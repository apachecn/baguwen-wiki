<!--yml
category: 未分类
date: 0001-01-01 00:00:00
-->

# 107.锁优化

> 原文：[https://zwmst.com/3122.html](https://zwmst.com/3122.html)

   [ *多线程* ](https://zwmst.com/%e5%a4%9a%e7%ba%bf%e7%a8%8b)*[ <time datetime="2021-09-16T00:24:28+08:00"> 2021-09-15 </time> ](https://zwmst.com/3122.html)  ### 减少锁持有时间

只用在有线程安全要求的程序上加锁

### 减小锁粒度

将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。

### 锁分离

**最常见的锁分离就是读写锁 ReadWriteLock**，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据

### 锁粗化

通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，**如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化** 。

### 锁消除

锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。

参考：[https://www.jianshu.com/p/39628e1180a9](https://www.jianshu.com/p/39628e1180a9)*